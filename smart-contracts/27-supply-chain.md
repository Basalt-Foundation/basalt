# Supply Chain Finance

## Category

Trade Finance / Supply Chain Management / Logistics / Real-World Assets (RWA)

## Summary

Supply Chain Finance is a contract suite that tracks goods through the supply chain using BST-721 non-fungible tokens (one per shipment), integrates milestone-based payment release via the Escrow system contract, enables trade finance (invoice discounting on receivables generated by shipments), and uses BST-VC Verifiable Credentials for supplier and carrier verification. The contract supports IoT oracle integration for delivery confirmation, creating an end-to-end digitized trade finance workflow from purchase order to final delivery and payment settlement.

Each shipment is represented as a unique BST-721 token that progresses through defined milestones (order placed, goods manufactured, shipped, in transit, customs cleared, delivered). At each milestone, designated oracles or verified participants confirm progression, triggering conditional payment releases from escrow. This creates a trustless trade finance system where buyers, sellers, carriers, and financiers interact through smart contract logic rather than relying on letters of credit, bills of lading, and paper-based documentation.

## Why It's Useful

- Global trade finance involves $5.2 trillion in annual volume but suffers from a $1.7 trillion funding gap, primarily affecting SMBs in developing economies; digitized supply chain finance reduces friction and expands access.
- Traditional letters of credit require extensive paperwork, multiple bank intermediaries, and 5-30 day processing times; on-chain milestone-based escrow provides instant, transparent settlement at each stage.
- Bill of lading fraud (fake shipping documents) costs global trade billions annually; BST-721 shipment tokens with IoT oracle confirmation provide tamper-proof proof of shipment and delivery.
- Supplier verification is costly and slow, requiring manual due diligence across jurisdictions; BST-VC credentials from recognized trade organizations provide instant, cryptographic supplier verification.
- Financing against shipments in transit (warehouse financing, in-transit financing) is underutilized because banks cannot verify goods location and status in real time; IoT oracle data on-chain enables real-time collateral monitoring.
- Multi-party coordination (buyer, seller, carrier, customs broker, financier, insurer) is the primary source of delay and cost in trade finance; a single on-chain state machine visible to all parties eliminates information asymmetry.
- Dispute resolution in international trade is expensive and slow; on-chain milestone evidence provides unambiguous proof for arbitration.

## Key Features

- Shipment token minting: BST-721 non-fungible tokens representing individual shipments, minted by verified sellers when a purchase order is confirmed.
- Milestone state machine: each shipment progresses through configurable milestones (ordered, manufactured, quality-checked, shipped, in-transit, customs-cleared, delivered, payment-released).
- Milestone-based escrow: buyer deposits payment into the Escrow system contract; partial releases at each milestone (e.g., 30% on shipment, 30% on customs clearance, 40% on delivery).
- IoT oracle integration: authorized IoT oracles (GPS trackers, temperature sensors, RFID scanners) report shipment status updates, triggering milestone advancement.
- Carrier verification: carriers and logistics providers are verified via BST-VC credentials from recognized trade organizations, preventing unauthorized handling.
- Supplier verification: sellers/manufacturers are verified via BST-VC credentials, enabling trust-minimized cross-border trade.
- Trade finance (invoice discounting): sellers can factor their shipment receivables to financiers at a discount, similar to the invoice factoring contract but tied to physical goods in transit.
- Document attachment: shipping documents (bill of lading, packing list, certificate of origin, insurance) are linked via IPFS hashes stored as token metadata.
- Quality inspection: designated inspectors can submit quality attestation at the manufacturing milestone, gating shipment progression.
- Customs integration: customs broker milestone confirmation for regulatory clearance, with document hash verification.
- Insurance integration: optional insurance escrow that pays out on shipment damage or loss, triggered by IoT damage detection oracles.
- Multi-leg shipment tracking: support for complex shipments with multiple carriers across different transport modes (sea, air, rail, road).
- Dispute escalation: if a milestone is contested, the shipment enters a dispute phase with evidence submission and governance-based resolution.

## Basalt-Specific Advantages

- **BST-VC Verifiable Credentials**: Supply chain verification is fundamentally an identity problem -- is this supplier legitimate? Is this carrier authorized? Is this inspector certified? Basalt's native BST-VC standard provides W3C-compliant credentials issued by recognized trade organizations (ICC, WTO, chambers of commerce) that are cryptographically verifiable on-chain. No other L1 has this identity primitive built into the protocol.
- **Escrow System Contract**: Basalt's protocol-level Escrow (0x...1003) provides battle-tested, time-locked fund custody that integrates natively with the supply chain milestone state machine. Milestone-based partial releases are orchestrated through cross-contract calls between the supply chain contract and Escrow, providing atomic settlement guarantees.
- **IssuerRegistry Integration**: Suppliers, carriers, inspectors, customs brokers, and IoT oracle operators are registered in the protocol-level IssuerRegistry. This creates a curated trust network where adding new participants requires governance approval while remaining decentralized.
- **ZK Compliance Layer**: International trade involves complex compliance requirements (sanctions screening, export controls, country-of-origin rules). Basalt's ZK proof system allows participants to prove compliance without revealing the full details of their trade relationships. A supplier can prove "I am not on any sanctions list and my goods comply with export controls" without revealing their customer list or trade volumes.
- **AOT-Compiled Execution**: Multi-milestone shipment processing with cross-contract calls to Escrow, IoT oracle verification, and document hash validation benefits from AOT compilation's predictable gas behavior.
- **Governance Integration**: Dispute resolution, new milestone type definitions, and oracle authorization flow through on-chain governance.
- **BridgeETH Integration**: Cross-chain trade finance where Ethereum-based buyers can participate in Basalt-native supply chain transactions.
- **Ed25519 Signatures**: Fast signature verification for high-frequency IoT oracle updates reporting shipment location and condition data.

## Token Standards Used

- **BST-721 (Non-Fungible Token)**: Primary standard. Each shipment is a unique token with metadata linking to shipping documents and tracking data.
- **BST-VC (Verifiable Credentials)**: Supplier certification, carrier authorization, inspector certification, customs broker verification, and IoT oracle registration.
- **BST-20 (Fungible Token)**: Payment settlement in native BST or BST-20 stablecoins via Escrow.

## Integration Points

- **Escrow (0x...1003)**: Core integration. Milestone-based payment escrow with partial release at each stage. The supply chain contract calls Escrow to create, partially release, and finalize payments.
- **SchemaRegistry (0x...1006)**: Defines credential schemas for "VerifiedSupplier", "AuthorizedCarrier", "CertifiedInspector", "CustomsBroker", and "IoTOracleOperator".
- **IssuerRegistry (0x...1007)**: Verifies that all supply chain participants are registered credential holders from authorized issuing bodies.
- **Governance (0x...1002)**: Dispute resolution, oracle authorization, milestone type governance, and parameter updates.
- **BNS (0x...1001)**: Suppliers, carriers, and trade finance platforms register human-readable names for discoverability.
- **BridgeETH (0x...1008)**: Cross-chain payment bridging for international trade transactions.

## Technical Sketch

```csharp
using Basalt.Core;

namespace Basalt.Sdk.Contracts.Standards;

/// <summary>
/// Supply Chain Finance contract.
/// BST-721 tokens represent individual shipments with milestone-based payment release.
/// Type ID: 0x010E
/// </summary>
[BasaltContract]
public partial class SupplyChainFinance
{
    // --- Shipment token state (BST-721) ---
    private readonly StorageValue<ulong> _nextShipmentId;
    private readonly StorageMap<string, string> _shipmentOwners;       // shipmentId -> owner hex
    private readonly StorageMap<string, string> _shipmentSellers;      // shipmentId -> seller hex
    private readonly StorageMap<string, string> _shipmentBuyers;       // shipmentId -> buyer hex
    private readonly StorageMap<string, string> _shipmentCarriers;     // shipmentId -> carrier hex
    private readonly StorageMap<string, string> _shipmentStatus;       // shipmentId -> current milestone name
    private readonly StorageMap<string, string> _shipmentMetadata;     // shipmentId -> IPFS hash of docs

    // --- Milestone state ---
    private readonly StorageMap<string, ulong> _milestoneCount;        // shipmentId -> number of milestones
    private readonly StorageMap<string, string> _milestoneNames;       // shipmentId:index -> milestone name
    private readonly StorageMap<string, ulong> _milestoneReleaseBps;   // shipmentId:index -> payment bps to release
    private readonly StorageMap<string, string> _milestoneCompleted;   // shipmentId:index -> "1" if completed
    private readonly StorageMap<string, ulong> _milestoneCompletedAt;  // shipmentId:index -> block completed
    private readonly StorageMap<string, string> _milestoneConfirmer;   // shipmentId:index -> confirmer address hex

    // --- Escrow integration ---
    private readonly StorageMap<string, ulong> _shipmentEscrowIds;     // shipmentId -> escrow ID
    private readonly StorageMap<string, UInt256> _shipmentTotalValue;   // shipmentId -> total payment value
    private readonly StorageMap<string, UInt256> _shipmentReleased;     // shipmentId -> amount released so far

    // --- Trade finance (invoice discounting) ---
    private readonly StorageMap<string, string> _shipmentFinancier;    // shipmentId -> financier hex (if factored)
    private readonly StorageMap<string, ulong> _shipmentDiscountBps;   // shipmentId -> discount rate if factored
    private readonly StorageMap<string, string> _shipmentFactored;     // shipmentId -> "1" if factored

    // --- IoT oracle state ---
    private readonly StorageMap<string, string> _authorizedOracles;    // oracle hex -> "1"
    private readonly StorageMap<string, string> _lastLocationReport;    // shipmentId -> location data string
    private readonly StorageMap<string, ulong> _lastLocationBlock;     // shipmentId -> block of last report
    private readonly StorageMap<string, string> _conditionAlerts;      // shipmentId -> latest condition alert

    // --- Dispute state ---
    private readonly StorageMap<string, string> _disputeStatus;        // shipmentId -> "none"/"open"/"resolved"
    private readonly StorageMap<string, string> _disputeEvidence;      // shipmentId -> evidence IPFS hash

    // --- Compliance ---
    private readonly StorageMap<string, string> _verifiedParticipants;  // address hex -> "1"

    // --- System contract addresses ---
    private readonly byte[] _escrowAddress;
    private readonly byte[] _issuerRegistryAddress;
    private readonly byte[] _schemaRegistryAddress;
    private readonly byte[] _governanceAddress;

    public SupplyChainFinance()
    {
        _nextShipmentId = new StorageValue<ulong>("sc_next");
        _shipmentOwners = new StorageMap<string, string>("sc_owner");
        _shipmentSellers = new StorageMap<string, string>("sc_seller");
        _shipmentBuyers = new StorageMap<string, string>("sc_buyer");
        _shipmentCarriers = new StorageMap<string, string>("sc_carrier");
        _shipmentStatus = new StorageMap<string, string>("sc_status");
        _shipmentMetadata = new StorageMap<string, string>("sc_meta");
        _milestoneCount = new StorageMap<string, ulong>("sc_mcount");
        _milestoneNames = new StorageMap<string, string>("sc_mname");
        _milestoneReleaseBps = new StorageMap<string, ulong>("sc_mrel");
        _milestoneCompleted = new StorageMap<string, string>("sc_mcomp");
        _milestoneCompletedAt = new StorageMap<string, ulong>("sc_mat");
        _milestoneConfirmer = new StorageMap<string, string>("sc_mconf");
        _shipmentEscrowIds = new StorageMap<string, ulong>("sc_escid");
        _shipmentTotalValue = new StorageMap<string, UInt256>("sc_total");
        _shipmentReleased = new StorageMap<string, UInt256>("sc_released");
        _shipmentFinancier = new StorageMap<string, string>("sc_fin");
        _shipmentDiscountBps = new StorageMap<string, ulong>("sc_disc");
        _shipmentFactored = new StorageMap<string, string>("sc_fact");
        _authorizedOracles = new StorageMap<string, string>("sc_oracle");
        _lastLocationReport = new StorageMap<string, string>("sc_loc");
        _lastLocationBlock = new StorageMap<string, ulong>("sc_locblk");
        _conditionAlerts = new StorageMap<string, string>("sc_alert");
        _disputeStatus = new StorageMap<string, string>("sc_disp");
        _disputeEvidence = new StorageMap<string, string>("sc_devid");
        _verifiedParticipants = new StorageMap<string, string>("sc_vpart");

        _escrowAddress = new byte[20];
        _escrowAddress[18] = 0x10;
        _escrowAddress[19] = 0x03;

        _issuerRegistryAddress = new byte[20];
        _issuerRegistryAddress[18] = 0x10;
        _issuerRegistryAddress[19] = 0x07;

        _schemaRegistryAddress = new byte[20];
        _schemaRegistryAddress[18] = 0x10;
        _schemaRegistryAddress[19] = 0x06;

        _governanceAddress = new byte[20];
        _governanceAddress[18] = 0x10;
        _governanceAddress[19] = 0x02;
    }

    // ================================================================
    // Shipment Creation
    // ================================================================

    /// <summary>
    /// Create a new shipment. Seller mints a BST-721 shipment token.
    /// Buyer must deposit payment into escrow simultaneously.
    /// Milestones and their payment release percentages are defined at creation.
    /// </summary>
    [BasaltEntrypoint]
    public ulong CreateShipment(
        byte[] buyer,
        byte[] carrier,
        string metadataIpfsHash,
        ulong milestoneCount,
        string milestoneNamesCsv,
        string milestoneReleaseBpsCsv)
    {
        // Verify seller is registered
        RequireVerifiedParticipant(Context.Caller);
        RequireVerifiedParticipant(buyer);
        RequireVerifiedParticipant(carrier);

        Context.Require(!Context.TxValue.IsZero, "SC: buyer must deposit payment");
        Context.Require(milestoneCount > 0 && milestoneCount <= 10, "SC: 1-10 milestones required");

        var shipmentId = _nextShipmentId.Get();
        _nextShipmentId.Set(shipmentId + 1);
        var shipKey = shipmentId.ToString();

        _shipmentOwners.Set(shipKey, Convert.ToHexString(Context.Caller));
        _shipmentSellers.Set(shipKey, Convert.ToHexString(Context.Caller));
        _shipmentBuyers.Set(shipKey, Convert.ToHexString(buyer));
        _shipmentCarriers.Set(shipKey, Convert.ToHexString(carrier));
        _shipmentStatus.Set(shipKey, "created");
        _shipmentMetadata.Set(shipKey, metadataIpfsHash);
        _shipmentTotalValue.Set(shipKey, Context.TxValue);
        _milestoneCount.Set(shipKey, milestoneCount);

        // Parse milestone names and release percentages from CSV strings
        // (In production, would use structured encoding; CSV for simplicity)
        StoreMilestones(shipKey, milestoneCount, milestoneNamesCsv, milestoneReleaseBpsCsv);

        // Create escrow for the payment
        var escrowId = Context.CallContract<ulong>(
            _escrowAddress, "Create", buyer, Context.BlockHeight + 864000);
        _shipmentEscrowIds.Set(shipKey, escrowId);

        Context.Emit(new ShipmentCreatedEvent
        {
            ShipmentId = shipmentId,
            Seller = Context.Caller,
            Buyer = buyer,
            Carrier = carrier,
            TotalValue = Context.TxValue,
            MilestoneCount = milestoneCount,
        });

        return shipmentId;
    }

    // ================================================================
    // Milestone Progression
    // ================================================================

    /// <summary>
    /// Confirm a milestone has been reached. Can be called by:
    /// - The carrier (for transit milestones)
    /// - An IoT oracle (for automated confirmations)
    /// - An inspector (for quality milestones)
    /// - A customs broker (for customs milestones)
    /// Releases the corresponding payment percentage from escrow.
    /// </summary>
    [BasaltEntrypoint]
    public void ConfirmMilestone(ulong shipmentId, ulong milestoneIndex)
    {
        var shipKey = shipmentId.ToString();
        Context.Require(_disputeStatus.Get(shipKey) != "open", "SC: shipment in dispute");

        var count = _milestoneCount.Get(shipKey);
        Context.Require(milestoneIndex < count, "SC: invalid milestone index");

        // Verify previous milestones are completed (sequential)
        if (milestoneIndex > 0)
        {
            var prevKey = shipKey + ":" + (milestoneIndex - 1).ToString();
            Context.Require(_milestoneCompleted.Get(prevKey) == "1", "SC: previous milestone not completed");
        }

        var mKey = shipKey + ":" + milestoneIndex.ToString();
        Context.Require(_milestoneCompleted.Get(mKey) != "1", "SC: milestone already completed");

        // Verify confirmer is authorized (carrier, oracle, or verified participant)
        var callerHex = Convert.ToHexString(Context.Caller);
        var isCarrier = callerHex == _shipmentCarriers.Get(shipKey);
        var isOracle = _authorizedOracles.Get(callerHex) == "1";
        var isVerified = _verifiedParticipants.Get(callerHex) == "1";
        Context.Require(isCarrier || isOracle || isVerified, "SC: not authorized to confirm");

        _milestoneCompleted.Set(mKey, "1");
        _milestoneCompletedAt.Set(mKey, Context.BlockHeight);
        _milestoneConfirmer.Set(mKey, callerHex);

        // Release payment for this milestone
        var releaseBps = _milestoneReleaseBps.Get(mKey);
        var totalValue = _shipmentTotalValue.Get(shipKey);
        var releaseAmount = totalValue * new UInt256(releaseBps) / new UInt256(10000);

        if (!releaseAmount.IsZero)
        {
            var payee = _shipmentFactored.Get(shipKey) == "1"
                ? _shipmentFinancier.Get(shipKey)
                : _shipmentSellers.Get(shipKey);

            _shipmentReleased.Set(shipKey, _shipmentReleased.Get(shipKey) + releaseAmount);
            Context.TransferNative(Convert.FromHexString(payee), releaseAmount);
        }

        // Update overall status to milestone name
        var milestoneName = _milestoneNames.Get(mKey);
        _shipmentStatus.Set(shipKey, milestoneName);

        // If final milestone, mark as delivered
        if (milestoneIndex == count - 1)
            _shipmentStatus.Set(shipKey, "delivered");

        Context.Emit(new MilestoneConfirmedEvent
        {
            ShipmentId = shipmentId,
            MilestoneIndex = milestoneIndex,
            MilestoneName = milestoneName,
            Confirmer = Context.Caller,
            AmountReleased = releaseAmount,
        });
    }

    // ================================================================
    // IoT Oracle Integration
    // ================================================================

    /// <summary>
    /// IoT oracle reports shipment location data.
    /// </summary>
    [BasaltEntrypoint]
    public void ReportLocation(ulong shipmentId, string locationData)
    {
        Context.Require(
            _authorizedOracles.Get(Convert.ToHexString(Context.Caller)) == "1",
            "SC: not authorized oracle");

        var shipKey = shipmentId.ToString();
        _lastLocationReport.Set(shipKey, locationData);
        _lastLocationBlock.Set(shipKey, Context.BlockHeight);

        Context.Emit(new LocationReportedEvent
        {
            ShipmentId = shipmentId,
            LocationData = locationData,
            Oracle = Context.Caller,
        });
    }

    /// <summary>
    /// IoT oracle reports a condition alert (temperature excursion, damage, etc.).
    /// </summary>
    [BasaltEntrypoint]
    public void ReportConditionAlert(ulong shipmentId, string alertData)
    {
        Context.Require(
            _authorizedOracles.Get(Convert.ToHexString(Context.Caller)) == "1",
            "SC: not authorized oracle");

        var shipKey = shipmentId.ToString();
        _conditionAlerts.Set(shipKey, alertData);

        Context.Emit(new ConditionAlertEvent
        {
            ShipmentId = shipmentId,
            AlertData = alertData,
            Oracle = Context.Caller,
        });
    }

    // ================================================================
    // Trade Finance (Invoice Discounting)
    // ================================================================

    /// <summary>
    /// Seller factors the shipment receivable to a financier at a discount.
    /// Future milestone payments will go to the financier instead of the seller.
    /// </summary>
    [BasaltEntrypoint]
    public void FactorShipment(ulong shipmentId, byte[] financier, ulong discountBps)
    {
        var shipKey = shipmentId.ToString();
        Context.Require(
            Convert.ToHexString(Context.Caller) == _shipmentSellers.Get(shipKey),
            "SC: only seller");
        Context.Require(_shipmentFactored.Get(shipKey) != "1", "SC: already factored");
        RequireVerifiedParticipant(financier);

        var totalValue = _shipmentTotalValue.Get(shipKey);
        var released = _shipmentReleased.Get(shipKey);
        var remaining = totalValue - released;
        var purchasePrice = remaining - (remaining * new UInt256(discountBps) / new UInt256(10000));

        // Financier must send the discounted purchase price
        Context.Require(Context.TxValue >= purchasePrice, "SC: insufficient factoring payment");

        _shipmentFactored.Set(shipKey, "1");
        _shipmentFinancier.Set(shipKey, Convert.ToHexString(financier));
        _shipmentDiscountBps.Set(shipKey, discountBps);

        // Pay seller the discounted amount now
        Context.TransferNative(Context.Caller, purchasePrice);

        Context.Emit(new ShipmentFactoredEvent
        {
            ShipmentId = shipmentId,
            Seller = Context.Caller,
            Financier = financier,
            DiscountBps = discountBps,
            PurchasePrice = purchasePrice,
        });
    }

    // ================================================================
    // Dispute Management
    // ================================================================

    /// <summary>
    /// Open a dispute on a shipment. Only buyer or seller.
    /// Freezes further milestone progression until resolved.
    /// </summary>
    [BasaltEntrypoint]
    public void OpenDispute(ulong shipmentId, string evidenceIpfsHash)
    {
        var shipKey = shipmentId.ToString();
        var callerHex = Convert.ToHexString(Context.Caller);
        Context.Require(
            callerHex == _shipmentBuyers.Get(shipKey) || callerHex == _shipmentSellers.Get(shipKey),
            "SC: only buyer or seller");
        Context.Require(_disputeStatus.Get(shipKey) != "open", "SC: dispute already open");

        _disputeStatus.Set(shipKey, "open");
        _disputeEvidence.Set(shipKey, evidenceIpfsHash);

        Context.Emit(new DisputeOpenedEvent
        {
            ShipmentId = shipmentId,
            Opener = Context.Caller,
            EvidenceHash = evidenceIpfsHash,
        });
    }

    /// <summary>
    /// Resolve a dispute. Governance-only.
    /// </summary>
    [BasaltEntrypoint]
    public void ResolveDispute(ulong shipmentId, string resolution)
    {
        Context.Require(
            Convert.ToHexString(Context.Caller) == Convert.ToHexString(_governanceAddress),
            "SC: only governance");

        var shipKey = shipmentId.ToString();
        Context.Require(_disputeStatus.Get(shipKey) == "open", "SC: no open dispute");

        _disputeStatus.Set(shipKey, "resolved");

        Context.Emit(new DisputeResolvedEvent
        {
            ShipmentId = shipmentId,
            Resolution = resolution,
        });
    }

    // ================================================================
    // Oracle Management
    // ================================================================

    [BasaltEntrypoint]
    public void AuthorizeOracle(byte[] oracle)
    {
        Context.Require(
            Convert.ToHexString(Context.Caller) == Convert.ToHexString(_governanceAddress),
            "SC: only governance");
        _authorizedOracles.Set(Convert.ToHexString(oracle), "1");
    }

    // ================================================================
    // Views
    // ================================================================

    [BasaltView]
    public string GetShipmentStatus(ulong shipmentId)
        => _shipmentStatus.Get(shipmentId.ToString()) ?? "unknown";

    [BasaltView]
    public UInt256 GetShipmentTotalValue(ulong shipmentId)
        => _shipmentTotalValue.Get(shipmentId.ToString());

    [BasaltView]
    public UInt256 GetShipmentReleased(ulong shipmentId)
        => _shipmentReleased.Get(shipmentId.ToString());

    [BasaltView]
    public bool IsMilestoneCompleted(ulong shipmentId, ulong milestoneIndex)
        => _milestoneCompleted.Get(shipmentId.ToString() + ":" + milestoneIndex.ToString()) == "1";

    [BasaltView]
    public string GetMilestoneName(ulong shipmentId, ulong milestoneIndex)
        => _milestoneNames.Get(shipmentId.ToString() + ":" + milestoneIndex.ToString()) ?? "";

    [BasaltView]
    public string GetLastLocation(ulong shipmentId)
        => _lastLocationReport.Get(shipmentId.ToString()) ?? "";

    [BasaltView]
    public string GetConditionAlert(ulong shipmentId)
        => _conditionAlerts.Get(shipmentId.ToString()) ?? "";

    [BasaltView]
    public bool IsFactored(ulong shipmentId)
        => _shipmentFactored.Get(shipmentId.ToString()) == "1";

    [BasaltView]
    public string GetDisputeStatus(ulong shipmentId)
        => _disputeStatus.Get(shipmentId.ToString()) ?? "none";

    [BasaltView]
    public ulong GetMilestoneCount(ulong shipmentId)
        => _milestoneCount.Get(shipmentId.ToString());

    // ================================================================
    // Internal helpers
    // ================================================================

    private void StoreMilestones(
        string shipKey, ulong count,
        string namesCsv, string releaseBpsCsv)
    {
        // Simple CSV parsing for milestone configuration
        // In production, would use structured binary encoding
        var names = namesCsv.Split(',');
        var bpsValues = releaseBpsCsv.Split(',');
        Context.Require(
            (ulong)names.Length == count && (ulong)bpsValues.Length == count,
            "SC: milestone count mismatch");

        ulong totalBps = 0;
        for (ulong i = 0; i < count; i++)
        {
            var mKey = shipKey + ":" + i.ToString();
            _milestoneNames.Set(mKey, names[i].Trim());
            var bps = ulong.Parse(bpsValues[i].Trim());
            _milestoneReleaseBps.Set(mKey, bps);
            totalBps += bps;
        }
        Context.Require(totalBps == 10000, "SC: milestone release bps must sum to 10000");
    }

    private void RequireVerifiedParticipant(byte[] participant)
    {
        var hex = Convert.ToHexString(participant);
        if (_verifiedParticipants.Get(hex) == "1") return;

        var isRegistered = Context.CallContract<bool>(
            _issuerRegistryAddress, "IsRegistered", participant);
        if (isRegistered)
        {
            _verifiedParticipants.Set(hex, "1");
            return;
        }

        Context.Require(false, "SC: participant not verified");
    }
}

// ================================================================
// Events
// ================================================================

[BasaltEvent]
public sealed class ShipmentCreatedEvent
{
    [Indexed] public ulong ShipmentId { get; init; }
    [Indexed] public byte[] Seller { get; init; } = [];
    public byte[] Buyer { get; init; } = [];
    public byte[] Carrier { get; init; } = [];
    public UInt256 TotalValue { get; init; }
    public ulong MilestoneCount { get; init; }
}

[BasaltEvent]
public sealed class MilestoneConfirmedEvent
{
    [Indexed] public ulong ShipmentId { get; init; }
    [Indexed] public ulong MilestoneIndex { get; init; }
    public string MilestoneName { get; init; } = "";
    public byte[] Confirmer { get; init; } = [];
    public UInt256 AmountReleased { get; init; }
}

[BasaltEvent]
public sealed class LocationReportedEvent
{
    [Indexed] public ulong ShipmentId { get; init; }
    public string LocationData { get; init; } = "";
    public byte[] Oracle { get; init; } = [];
}

[BasaltEvent]
public sealed class ConditionAlertEvent
{
    [Indexed] public ulong ShipmentId { get; init; }
    public string AlertData { get; init; } = "";
    public byte[] Oracle { get; init; } = [];
}

[BasaltEvent]
public sealed class ShipmentFactoredEvent
{
    [Indexed] public ulong ShipmentId { get; init; }
    public byte[] Seller { get; init; } = [];
    public byte[] Financier { get; init; } = [];
    public ulong DiscountBps { get; init; }
    public UInt256 PurchasePrice { get; init; }
}

[BasaltEvent]
public sealed class DisputeOpenedEvent
{
    [Indexed] public ulong ShipmentId { get; init; }
    public byte[] Opener { get; init; } = [];
    public string EvidenceHash { get; init; } = "";
}

[BasaltEvent]
public sealed class DisputeResolvedEvent
{
    [Indexed] public ulong ShipmentId { get; init; }
    public string Resolution { get; init; } = "";
}
```

## Complexity

**High** -- This contract manages a multi-party state machine (buyer, seller, carrier, inspector, customs broker, financier, IoT oracle) with sequential milestone progression, conditional payment release through cross-contract Escrow calls, IoT data ingestion, trade finance factoring, and dispute resolution. The milestone system alone requires careful sequential validation. Integration with five system contracts (Escrow, IssuerRegistry, SchemaRegistry, Governance, BNS) adds substantial cross-contract coordination. The factoring mechanism changes payment routing mid-shipment, requiring careful accounting.

## Priority

**P2** -- Supply chain finance addresses a massive market gap ($1.7 trillion trade finance deficit) and showcases Basalt's unique strengths (BST-VC for multi-party verification, Escrow for milestone payments, IoT oracle integration). However, real-world adoption requires extensive off-chain integration (IoT hardware, logistics systems, customs APIs) that is beyond the blockchain layer. Higher priority than purely consumer-facing use cases (music royalties, art) but lower than financial instruments that can be adopted with minimal off-chain dependencies.
