# Basalt.Codec

Deterministic binary serialization for the Basalt blockchain. All on-chain data (blocks, transactions, state) is encoded through this codec to ensure identical byte representations across all nodes.

## Components

### BasaltWriter

Stack-allocated `ref struct` writer that serializes data into a `Span<byte>` buffer.

```csharp
Span<byte> buffer = stackalloc byte[256];
var writer = new BasaltWriter(buffer);

// Primitives
writer.WriteByte(0x01);
writer.WriteBool(true);                   // 1 byte (0x00 or 0x01)
writer.WriteUInt16(value);                // 2 bytes, little-endian
writer.WriteUInt32(value);                // 4 bytes, little-endian
writer.WriteInt32(value);                 // 4 bytes, little-endian
writer.WriteUInt64(42);                   // 8 bytes, little-endian
writer.WriteInt64(value);                 // 8 bytes, little-endian
writer.WriteVarInt(value);                // LEB128 variable-length

// Byte arrays
writer.WriteBytes(data);                  // Length-prefixed (VarInt length + data)
writer.WriteRawBytes(fixedData);          // No prefix, raw bytes

// Strings
writer.WriteString("hello");              // UTF-8, length-prefixed (VarInt length)

// Basalt types (fixed-size, no prefix)
writer.WriteHash256(hash);                // 32 bytes
writer.WriteAddress(addr);                // 20 bytes
writer.WriteUInt256(balance);             // 32 bytes
writer.WriteSignature(sig);               // 64 bytes
writer.WritePublicKey(pubKey);            // 32 bytes
writer.WriteBlsSignature(blsSig);         // 96 bytes
writer.WriteBlsPublicKey(blsPub);         // 48 bytes

// State
int pos = writer.Position;
int rem = writer.Remaining;
ReadOnlySpan<byte> encoded = writer.WrittenSpan;
```

### BasaltReader

Stack-allocated `ref struct` reader that deserializes from a `ReadOnlySpan<byte>`.

```csharp
var reader = new BasaltReader(encoded);

// Primitives
byte b = reader.ReadByte();
bool flag = reader.ReadBool();
ushort u16 = reader.ReadUInt16();
uint u32 = reader.ReadUInt32();
int i32 = reader.ReadInt32();
ulong val = reader.ReadUInt64();
long i64 = reader.ReadInt64();
ulong varVal = reader.ReadVarInt();

// Byte arrays
ReadOnlySpan<byte> data = reader.ReadBytes();          // Length-prefixed
ReadOnlySpan<byte> raw = reader.ReadRawBytes(count);   // Fixed count, no prefix

// Strings
string text = reader.ReadString();

// Basalt types
Hash256 hash = reader.ReadHash256();                   // 32 bytes
Address addr = reader.ReadAddress();                   // 20 bytes
UInt256 balance = reader.ReadUInt256();                 // 32 bytes
Signature sig = reader.ReadSignature();                // 64 bytes
PublicKey pub = reader.ReadPublicKey();                 // 32 bytes
BlsSignature blsSig = reader.ReadBlsSignature();       // 96 bytes
BlsPublicKey blsPub = reader.ReadBlsPublicKey();       // 48 bytes

// State
int pos = reader.Position;
int rem = reader.Remaining;
bool done = reader.IsAtEnd;
```

### IBasaltSerializable\<T\>

Interface for types that can be serialized/deserialized. Implementations are generated by the `Basalt.Generators.Codec` source generator.

```csharp
public interface IBasaltSerializable<T> where T : IBasaltSerializable<T>
{
    void WriteTo(ref BasaltWriter writer);
    static abstract T ReadFrom(ref BasaltReader reader);
    int GetSerializedSize();
}
```

Usage with the `[BasaltSerializable]` attribute:

```csharp
[BasaltSerializable]
public partial struct MyType : IBasaltSerializable<MyType>
{
    public ulong Id;
    public Address Owner;
}

// Serialize
byte[] bytes = BasaltSerializer.Serialize(myValue);

// Deserialize (accepts ReadOnlySpan<byte>)
MyType restored = BasaltSerializer.Deserialize<MyType>(bytes);
```

## Design Decisions

- **ref struct** -- `BasaltWriter` and `BasaltReader` are `ref struct` to enable stack allocation and avoid heap pressure. This means they cannot be captured in lambdas, stored in fields, or used in async methods.
- **VarInt** -- Uses LEB128 encoding for compact representation of small integers (nonces, lengths, indices).
- **Deterministic** -- Identical inputs always produce identical byte sequences. No padding, no alignment, no optional fields.
- **Bounds-checked** -- Both reader and writer throw `InvalidOperationException` on buffer overrun.

## Dependencies

| Package | Purpose |
|---------|---------|
| `Basalt.Core` | Hash256, Address, UInt256, Signature, PublicKey, BlsSignature, BlsPublicKey |
